module runtime

import compiler

fn emit_runtime() -> string {
    let mut r = "// dAImond Generated C Code\n"
    r = r + "// Generated by dAImond Stage 1 Compiler\n\n"
    r = r + "#include <stdint.h>\n"
    r = r + "#include <stdbool.h>\n"
    r = r + "#include <stddef.h>\n"
    r = r + "#include <stdlib.h>\n"
    r = r + "#include <string.h>\n"
    r = r + "#include <stdio.h>\n"
    r = r + "#include <errno.h>\n\n"
    r = r + "// Runtime Types\n\n"
    r = r + "typedef struct dm_string {\n"
    r = r + "    const char* data;\n"
    r = r + "    size_t len;\n"
    r = r + "    size_t capacity;\n"
    r = r + "} dm_string;\n\n"
    r = r + "// Runtime Functions\n\n"
    r = r + "static inline dm_string dm_string_from_cstr(const char* s) {\n"
    r = r + "    size_t len = strlen(s);\n"
    r = r + "    return (dm_string){ .data = s, .len = len, .capacity = len };\n"
    r = r + "}\n\n"
    r = r + "static inline bool dm_string_eq(dm_string a, dm_string b) {\n"
    r = r + "    if (a.len != b.len) return false;\n"
    r = r + "    return memcmp(a.data, b.data, a.len) == 0;\n"
    r = r + "}\n\n"
    r = r + "static inline dm_string dm_string_concat(dm_string a, dm_string b) {\n"
    r = r + "    size_t new_len = a.len + b.len;\n"
    r = r + "    char* buf = (char*)malloc(new_len + 1);\n"
    r = r + "    memcpy(buf, a.data, a.len);\n"
    r = r + "    memcpy(buf + a.len, b.data, b.len);\n"
    r = r + "    buf[new_len] = '\\0';\n"
    r = r + "    return (dm_string){ .data = buf, .len = new_len, .capacity = new_len };\n"
    r = r + "}\n\n"
    r = r + "static inline void dm_print_str(dm_string s) { fwrite(s.data, 1, s.len, stdout); }\n"
    r = r + "static inline void dm_println_str(dm_string s) { fwrite(s.data, 1, s.len, stdout); putchar('\\n'); }\n"
    r = r + "static inline void dm_eprintln_str(dm_string s) { fwrite(s.data, 1, s.len, stderr); fputc('\\n', stderr); }\n"
    r = r + "static inline void dm_eprint_str(dm_string s) { fwrite(s.data, 1, s.len, stderr); }\n\n"
    r = r + "static inline dm_string dm_int_to_string(int64_t n) {\n"
    r = r + "    char buf[32];\n"
    r = r + "    int len = snprintf(buf, sizeof(buf), \"%lld\", (long long)n);\n"
    r = r + "    char* result = (char*)malloc(len + 1);\n"
    r = r + "    memcpy(result, buf, len + 1);\n"
    r = r + "    return (dm_string){ .data = result, .len = (size_t)len, .capacity = (size_t)len };\n"
    r = r + "}\n\n"
    r = r + "static inline dm_string dm_bool_to_string(bool b) {\n"
    r = r + "    return b ? dm_string_from_cstr(\"true\") : dm_string_from_cstr(\"false\");\n"
    r = r + "}\n\n"
    r = r + "static inline dm_string dm_float_to_string(double f) {\n"
    r = r + "    char buf[64];\n"
    r = r + "    int len = snprintf(buf, sizeof(buf), \"%g\", f);\n"
    r = r + "    char* result = (char*)malloc(len + 1);\n"
    r = r + "    memcpy(result, buf, len + 1);\n"
    r = r + "    return (dm_string){ .data = result, .len = (size_t)len, .capacity = (size_t)len };\n"
    r = r + "}\n\n"
    r = r + "static inline void dm_panic_cstr(const char* msg) { fprintf(stderr, \"PANIC: %s\\n\", msg); exit(1); }\n"
    r = r + "static inline void dm_panic(dm_string msg) { fprintf(stderr, \"PANIC: \"); fwrite(msg.data, 1, msg.len, stderr); fputc('\\n', stderr); exit(1); }\n"
    r = r + "static inline void dm_exit(int64_t code) { exit((int)code); }\n\n"
    -- Generic list macros (type-agnostic, works with any list struct)
    r = r + "#define DM_LIST_PUSH(list, val) do { \\\n"
    r = r + "    if ((list).len >= (list).capacity) { \\\n"
    r = r + "        size_t _nc = (list).capacity == 0 ? 8 : (list).capacity * 2; \\\n"
    r = r + "        void* _nd = realloc((list).data, _nc * sizeof(*(list).data)); \\\n"
    r = r + "        if (!_nd) dm_panic_cstr(\"list push: out of memory\"); \\\n"
    r = r + "        (list).data = _nd; \\\n"
    r = r + "        (list).capacity = _nc; \\\n"
    r = r + "    } \\\n"
    r = r + "    (list).data[(list).len] = (val); \\\n"
    r = r + "    (list).len++; \\\n"
    r = r + "} while(0)\n\n"
    r = r + "#define DM_LIST_LEN(list) ((int64_t)(list).len)\n"
    r = r + "#define DM_LIST_GET(list, idx) ((list).data[idx])\n"
    r = r + "#define DM_LIST_POP(list) ((list).data[--(list).len])\n"
    r = r + "static inline bool dm_list_generic_contains(void* list_ptr, void* val_ptr, size_t elem_size) {\n"
    r = r + "    size_t len = *(size_t*)((char*)list_ptr + sizeof(void*));\n"
    r = r + "    char* data = *(char**)list_ptr;\n"
    r = r + "    for (size_t i = 0; i < len; i++) {\n"
    r = r + "        if (memcmp(data + i * elem_size, val_ptr, elem_size) == 0) return true;\n"
    r = r + "    }\n"
    r = r + "    return false;\n"
    r = r + "}\n"
    r = r + "#define DM_LIST_CONTAINS(list, val) dm_list_generic_contains(&(list), &(val), sizeof(val))\n\n"
    r = r + "static int dm_argc = 0;\n"
    r = r + "static char** dm_argv = NULL;\n"
    r = r + "static inline dm_string dm_args_get(int64_t i) {\n"
    r = r + "    if (i < 0 || i >= (int64_t)dm_argc) return (dm_string){ .data = \"\", .len = 0, .capacity = 0 };\n"
    r = r + "    return dm_string_from_cstr(dm_argv[i]);\n"
    r = r + "}\n"
    r = r + "static inline int64_t dm_args_len(void) { return (int64_t)dm_argc; }\n\n"
    r = r + "static inline dm_string dm_file_read(dm_string path) {\n"
    r = r + "    char* cpath = (char*)malloc(path.len + 1);\n"
    r = r + "    memcpy(cpath, path.data, path.len);\n"
    r = r + "    cpath[path.len] = '\\0';\n"
    r = r + "    FILE* f = fopen(cpath, \"rb\");\n"
    r = r + "    free(cpath);\n"
    r = r + "    if (!f) dm_panic_cstr(\"file_read: cannot open file\");\n"
    r = r + "    fseek(f, 0, SEEK_END);\n"
    r = r + "    long sz = ftell(f);\n"
    r = r + "    fseek(f, 0, SEEK_SET);\n"
    r = r + "    char* buf = (char*)malloc((size_t)sz + 1);\n"
    r = r + "    size_t rd = fread(buf, 1, (size_t)sz, f);\n"
    r = r + "    fclose(f);\n"
    r = r + "    buf[rd] = '\\0';\n"
    r = r + "    return (dm_string){ .data = buf, .len = rd, .capacity = (size_t)sz };\n"
    r = r + "}\n\n"
    r = r + "static inline void dm_file_write(dm_string path, dm_string content) {\n"
    r = r + "    char* cpath = (char*)malloc(path.len + 1);\n"
    r = r + "    memcpy(cpath, path.data, path.len);\n"
    r = r + "    cpath[path.len] = '\\0';\n"
    r = r + "    FILE* f = fopen(cpath, \"wb\");\n"
    r = r + "    free(cpath);\n"
    r = r + "    if (!f) dm_panic_cstr(\"file_write: cannot open file\");\n"
    r = r + "    fwrite(content.data, 1, content.len, f);\n"
    r = r + "    fclose(f);\n"
    r = r + "}\n\n"
    r = r + "static inline dm_string dm_string_substr(dm_string s, int64_t start, int64_t length) {\n"
    r = r + "    if (start < 0 || (size_t)start >= s.len) return (dm_string){ .data = \"\", .len = 0, .capacity = 0 };\n"
    r = r + "    size_t actual_len = (size_t)length;\n"
    r = r + "    if ((size_t)start + actual_len > s.len) actual_len = s.len - (size_t)start;\n"
    r = r + "    char* buf = (char*)malloc(actual_len + 1);\n"
    r = r + "    memcpy(buf, s.data + start, actual_len);\n"
    r = r + "    buf[actual_len] = '\\0';\n"
    r = r + "    return (dm_string){ .data = buf, .len = actual_len, .capacity = actual_len };\n"
    r = r + "}\n\n"
    r = r + "static inline int64_t dm_parse_int(dm_string s) {\n"
    r = r + "    char buf[32];\n"
    r = r + "    size_t cl = s.len < 31 ? s.len : 31;\n"
    r = r + "    memcpy(buf, s.data, cl);\n"
    r = r + "    buf[cl] = '\\0';\n"
    r = r + "    char *end;\n"
    r = r + "    errno = 0;\n"
    r = r + "    int64_t val = (int64_t)strtoll(buf, &end, 10);\n"
    r = r + "    if (end == buf || errno == ERANGE) return 0;\n"
    r = r + "    return val;\n"
    r = r + "}\n\n"
    r = r + "static inline double dm_parse_float(dm_string s) {\n"
    r = r + "    char buf[64];\n"
    r = r + "    size_t cl = s.len < 63 ? s.len : 63;\n"
    r = r + "    memcpy(buf, s.data, cl);\n"
    r = r + "    buf[cl] = '\\0';\n"
    r = r + "    return strtod(buf, NULL);\n"
    r = r + "}\n\n"
    r = r + "static inline dm_string dm_string_to_upper(dm_string s) {\n"
    r = r + "    char* buf = (char*)malloc(s.len + 1);\n"
    r = r + "    for (size_t i = 0; i < s.len; i++) {\n"
    r = r + "        char c = s.data[i];\n"
    r = r + "        buf[i] = (c >= 'a' && c <= 'z') ? (c - 32) : c;\n"
    r = r + "    }\n"
    r = r + "    buf[s.len] = '\\0';\n"
    r = r + "    return (dm_string){ .data = buf, .len = s.len, .capacity = s.len };\n"
    r = r + "}\n\n"
    r = r + "static inline dm_string dm_string_to_lower(dm_string s) {\n"
    r = r + "    char* buf = (char*)malloc(s.len + 1);\n"
    r = r + "    for (size_t i = 0; i < s.len; i++) {\n"
    r = r + "        char c = s.data[i];\n"
    r = r + "        buf[i] = (c >= 'A' && c <= 'Z') ? (c + 32) : c;\n"
    r = r + "    }\n"
    r = r + "    buf[s.len] = '\\0';\n"
    r = r + "    return (dm_string){ .data = buf, .len = s.len, .capacity = s.len };\n"
    r = r + "}\n\n"
    r = r + "static inline bool dm_string_contains(dm_string h, dm_string n) {\n"
    r = r + "    if (n.len == 0) return true;\n"
    r = r + "    if (n.len > h.len) return false;\n"
    r = r + "    for (size_t i = 0; i <= h.len - n.len; i++) {\n"
    r = r + "        if (memcmp(h.data + i, n.data, n.len) == 0) return true;\n"
    r = r + "    }\n"
    r = r + "    return false;\n"
    r = r + "}\n\n"
    r = r + "static inline int64_t dm_string_find(dm_string h, dm_string n) {\n"
    r = r + "    if (n.len == 0) return 0;\n"
    r = r + "    if (n.len > h.len) return -1;\n"
    r = r + "    for (size_t i = 0; i <= h.len - n.len; i++) {\n"
    r = r + "        if (memcmp(h.data + i, n.data, n.len) == 0) return (int64_t)i;\n"
    r = r + "    }\n"
    r = r + "    return -1;\n"
    r = r + "}\n\n"
    r = r + "static inline bool dm_string_starts_with(dm_string s, dm_string p) {\n"
    r = r + "    if (p.len > s.len) return false;\n"
    r = r + "    return memcmp(s.data, p.data, p.len) == 0;\n"
    r = r + "}\n\n"
    r = r + "static inline bool dm_string_ends_with(dm_string s, dm_string x) {\n"
    r = r + "    if (x.len > s.len) return false;\n"
    r = r + "    return memcmp(s.data + s.len - x.len, x.data, x.len) == 0;\n"
    r = r + "}\n\n"
    r = r + "static inline dm_string dm_string_replace(dm_string s, dm_string old_s, dm_string new_s) {\n"
    r = r + "    if (old_s.len == 0) return s;\n"
    r = r + "    size_t count = 0;\n"
    r = r + "    for (size_t i = 0; i + old_s.len <= s.len; i++) {\n"
    r = r + "        if (memcmp(s.data + i, old_s.data, old_s.len) == 0) { count++; i += old_s.len - 1; }\n"
    r = r + "    }\n"
    r = r + "    if (count == 0) { char* b = (char*)malloc(s.len+1); memcpy(b,s.data,s.len); b[s.len]='\\0'; return (dm_string){.data=b,.len=s.len,.capacity=s.len}; }\n"
    r = r + "    size_t nl;\n"
    r = r + "    if (new_s.len >= old_s.len) {\n"
    r = r + "        size_t growth = count * (new_s.len - old_s.len);\n"
    r = r + "        if (growth / count != (new_s.len - old_s.len) || s.len + growth < s.len) {\n"
    r = r + "            char* b = (char*)malloc(s.len+1); memcpy(b,s.data,s.len); b[s.len]='\\0';\n"
    r = r + "            return (dm_string){.data=b,.len=s.len,.capacity=s.len};\n"
    r = r + "        }\n"
    r = r + "        nl = s.len + growth;\n"
    r = r + "    } else { nl = s.len - count * (old_s.len - new_s.len); }\n"
    r = r + "    char* buf = (char*)malloc(nl + 1);\n"
    r = r + "    size_t pos = 0;\n"
    r = r + "    for (size_t i = 0; i < s.len; ) {\n"
    r = r + "        if (i + old_s.len <= s.len && memcmp(s.data+i, old_s.data, old_s.len)==0) {\n"
    r = r + "            memcpy(buf+pos, new_s.data, new_s.len); pos += new_s.len; i += old_s.len;\n"
    r = r + "        } else { buf[pos++] = s.data[i++]; }\n"
    r = r + "    }\n"
    r = r + "    buf[nl] = '\\0';\n"
    r = r + "    return (dm_string){ .data = buf, .len = nl, .capacity = nl };\n"
    r = r + "}\n\n"
    r = r + "static inline dm_string dm_string_trim(dm_string s) {\n"
    r = r + "    size_t start = 0;\n"
    r = r + "    while (start < s.len && (s.data[start]==' '||s.data[start]=='\\t'||s.data[start]=='\\n'||s.data[start]=='\\r')) start++;\n"
    r = r + "    size_t end = s.len;\n"
    r = r + "    while (end > start && (s.data[end-1]==' '||s.data[end-1]=='\\t'||s.data[end-1]=='\\n'||s.data[end-1]=='\\r')) end--;\n"
    r = r + "    size_t nl = end - start;\n"
    r = r + "    if (nl == 0) return (dm_string){ .data = \"\", .len = 0, .capacity = 0 };\n"
    r = r + "    char* buf = (char*)malloc(nl + 1); memcpy(buf, s.data + start, nl); buf[nl] = '\\0';\n"
    r = r + "    return (dm_string){ .data = buf, .len = nl, .capacity = nl };\n"
    r = r + "}\n\n"
    r = r + "static inline int64_t dm_system(dm_string cmd) {\n"
    r = r + "    char* c = (char*)malloc(cmd.len + 1); memcpy(c, cmd.data, cmd.len); c[cmd.len] = '\\0';\n"
    r = r + "    int r = system(c); free(c); return (int64_t)r;\n"
    r = r + "}\n\n"
    r = r + "static inline dm_string dm_char_at(dm_string s, int64_t i) {\n"
    r = r + "    if (i < 0 || (size_t)i >= s.len) return (dm_string){ .data = \"\", .len = 0, .capacity = 0 };\n"
    r = r + "    char* buf = (char*)malloc(2); buf[0] = s.data[i]; buf[1] = '\\0';\n"
    r = r + "    return (dm_string){ .data = buf, .len = 1, .capacity = 1 };\n"
    r = r + "}\n\n"
    r = r + "static inline int64_t dm_len(dm_string s) { return (int64_t)s.len; }\n\n"
    r = r + "static inline int dm_string_cmp(dm_string a, dm_string b) {\n"
    r = r + "    size_t min_len = a.len < b.len ? a.len : b.len;\n"
    r = r + "    int c = memcmp(a.data, b.data, min_len);\n"
    r = r + "    if (c != 0) return c;\n"
    r = r + "    if (a.len < b.len) return -1;\n"
    r = r + "    if (a.len > b.len) return 1;\n"
    r = r + "    return 0;\n"
    r = r + "}\n"
    r = r + "static inline bool dm_string_lt(dm_string a, dm_string b) { return dm_string_cmp(a, b) < 0; }\n"
    r = r + "static inline bool dm_string_gt(dm_string a, dm_string b) { return dm_string_cmp(a, b) > 0; }\n"
    r = r + "static inline bool dm_string_lteq(dm_string a, dm_string b) { return dm_string_cmp(a, b) <= 0; }\n"
    r = r + "static inline bool dm_string_gteq(dm_string a, dm_string b) { return dm_string_cmp(a, b) >= 0; }\n\n"
    -- Arena type and functions for region support
    r = r + "// Arena (Region Memory Management)\n\n"
    r = r + "typedef struct dm_arena {\n"
    r = r + "    char* data;\n"
    r = r + "    size_t size;\n"
    r = r + "    size_t used;\n"
    r = r + "    struct dm_arena* next;\n"
    r = r + "} dm_arena;\n\n"
    r = r + "static dm_arena* dm_arena_create(size_t initial_size) {\n"
    r = r + "    dm_arena* arena = (dm_arena*)malloc(sizeof(dm_arena));\n"
    r = r + "    if (!arena) return NULL;\n"
    r = r + "    arena->data = (char*)malloc(initial_size);\n"
    r = r + "    if (!arena->data) { free(arena); return NULL; }\n"
    r = r + "    arena->size = initial_size;\n"
    r = r + "    arena->used = 0;\n"
    r = r + "    arena->next = NULL;\n"
    r = r + "    return arena;\n"
    r = r + "}\n\n"
    r = r + "static void dm_arena_destroy(dm_arena* arena) {\n"
    r = r + "    if (!arena) return;\n"
    r = r + "    dm_arena* current = arena;\n"
    r = r + "    while (current) {\n"
    r = r + "        dm_arena* next = current->next;\n"
    r = r + "        free(current->data);\n"
    r = r + "        free(current);\n"
    r = r + "        current = next;\n"
    r = r + "    }\n"
    r = r + "}\n\n"

    r = r + "// End of Runtime\n\n"
    return r
}

fn emit_list_type_def(list_type: string, elem_type: string) -> string {
    let mut d = "typedef struct " + list_type + " {\n"
    d = d + "    " + elem_type + "* data;\n"
    d = d + "    size_t len;\n"
    d = d + "    size_t capacity;\n"
    d = d + "} " + list_type + ";\n\n"
    d = d + "static inline " + list_type + " " + list_type + "_new(void) {\n"
    d = d + "    return (" + list_type + "){ .data = NULL, .len = 0, .capacity = 0 };\n"
    d = d + "}\n\n"
    return d
}

fn assemble_output(c: Compiler) -> string {
    let mut out = emit_runtime()

    -- Forward declare all struct types (so list types can use pointers)
    let mut si = 0
    while si < c.struct_names.len() {
        let sname = "dm_" + c.struct_names[si]
        let fwd = "typedef struct " + sname + " " + sname + ";\n"
        out = out + fwd
        si = si + 1
    }
    out = out + "\n"

    -- List type definitions (after forward declarations, before full struct defs)
    out = out + c.list_type_defs

    -- Option/Result type definitions
    out = out + c.option_type_defs

    -- Struct/enum definitions
    let mut i = 0
    while i < c.struct_defs.len() {
        out = out + c.struct_defs[i]
        i = i + 1
    }

    -- Forward declarations
    let mut j = 0
    while j < c.fn_sigs.len() {
        out = out + c.fn_sigs[j] + "\n"
        j = j + 1
    }
    out = out + "\n"

    -- Lambda definitions (lifted anonymous functions)
    out = out + c.lambda_defs

    -- Function definitions
    let mut k = 0
    while k < c.fn_defs.len() {
        out = out + c.fn_defs[k]
        k = k + 1
    }

    -- main() wrapper
    out = out + "int main(int argc, char** argv) {\n"
    out = out + "    dm_argc = argc;\n"
    out = out + "    dm_argv = argv;\n"
    out = out + "    dm_main();\n"
    out = out + "    return 0;\n"
    out = out + "}\n"

    return out
}
